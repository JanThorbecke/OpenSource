#define _FILE_OFFSET_BITS 64
#define _LARGEFILE_SOURCE
#define _LARGEFILE64_SOURCE

#define ROUND_UP(x, s) (((x)+((s)-1)) & -(s))

#include<stdio.h>
#include<math.h>
#include"fdelrtmc.h"
#include"segy.h"
#include"par.h"
#include"transpose.h"

int readSrcWav(srcPar *src, modPar *mod, bndPar *bnd){
	FILE *fp;
	segy hdr;
	size_t i, isrc, nt, nx;
	float *ptr;
	float scalco, scalel;

	/***************************/
	/* Read First Trace Header */
	/***************************/
	fp=fopen(src->file_src,"r");
	fread(&hdr,1,TRCBYTES,fp);
	if(fseeko(fp,0,SEEK_END)<0)perror("fseekend");
	src->nsrc=(((size_t)ftello(fp))/((size_t)TRCBYTES+((size_t)hdr.ns)*sizeof(float))); /* Number of sources */
	if(fseeko(fp,TRCBYTES,SEEK_SET)<0)perror("fseekset");
	if(hdr.trid<1||hdr.trid>24) verr("In source file %s trace %d has an unknown source type (%d)",src->file_src,1,hdr.trid);
	if(hdr.delrt!=0) verr("In source file %s trace %d has a non-zero delay time (%d)",src->file_src,1,hdr.delrt);
	if(mod->nt==0){
		mod->nt=(size_t)hdr.ns;
		mod->dtus=hdr.dt;
		mod->dt=((float)mod->dtus)/1000000.0;
		if(mod->nt==0) verr("Source trace %d does has 0 samples, more were expected.",1);
		if(mod->dtus==0) verr("Source trace %d does has a 0 temproal sampling rate.",1);
	}else{
		if(((size_t)hdr.ns)!=mod->nt)verr("Source trace %d does has %d samples, expected were %d.",1,hdr.ns,mod->nt);
		if(hdr.dt!=mod->dtus)verr("Source trace %d does has a sampling rate of %dus, expected were %dus.",1,hdr.dt,mod->dtus);
	}

	/******************/
	/* Allocate Array */
	/******************/
	nt=ROUND_UP(mod->nt,16);nx=ROUND_UP(src->nsrc,16);
	src->xi=(size_t*)malloc(src->nsrc*sizeof(size_t));               /* Horizontal Grid Index Source Location */
	src->zi=(size_t*)malloc(src->nsrc*sizeof(size_t));               /* Vertical   Grid Index Source Location */
	src->typ=(int*)malloc(src->nsrc*sizeof(int));                    /* Source Type */
	src->orient=(int*)malloc(src->nsrc*sizeof(int));                 /* Source Orientation */
	src->x=(float*)malloc(src->nsrc*sizeof(float));                  /* Horizontal Source Location */
	src->z=(float*)malloc(src->nsrc*sizeof(float));                  /* Vertical   Source Location */
	if(src->nsrc==1) src->wav=(float*)malloc(mod->nt*sizeof(float)); /* Source Trace */
	else src->wav=(float*)_mm_malloc(nt*nx*sizeof(float),64);        /* Source Trace (Transpose)*/

	/***************************/
	/* Read Data & Resample(?) */
	/***************************/
	// Source Type & Orientation
	if(hdr.trid<1||hdr.trid>24) verr("In source file %s trace %d has an unknown source type (%d)",src->file_src,1,hdr.trid);
	*(src->typ)=(hdr.trid-1)%8+1;
	*(src->orient)=(hdr.trid-1)/8+1;
	// Horizontal Source Location
	if(hdr.scalco<0){scalco=1/-((float)hdr.scalco);}else if(hdr.scalco>0){scalco=((float)hdr.scalco);}else scalco=1.;
	scalel=((float)hdr.sx)*scalco;
	if(scalel<mod->origx||scalel>mod->xmax) verr("In source file %s trace %d lies outside model bounds.",src->file_src,1);
	scalel=(scalel-mod->origx)/mod->dx+0.5;
	*(src->x)=truncf(scalel)*mod->dx+mod->origx;
	if(*(src->typ)==2||*(src->typ)==6){
		*(src->xi)=mod->ioXx+((size_t)scalel);
	}else{
		*(src->xi)=mod->ioPx+((size_t)scalel);
	}
	// Vertical Source Location
	if(hdr.scalel<0){scalel=1/-((float)hdr.scalel);}else if(hdr.scalel>0){scalel=((float)hdr.scalel);}else scalel=1.;
	scalco=((float)hdr.selev)*scalel;
	if(scalco<mod->origz||scalco>mod->zmax) verr("In source file %s trace %d lies outside model bounds.",src->file_src,1);
	scalco=(scalco-mod->origz)/mod->dz+0.5;
	*(src->z)=truncf(scalco)*mod->dz+mod->origz;
	if(*(src->typ)==2||*(src->typ)==7){
		*(src->zi)=mod->ioZz+((size_t)scalco);
	}else{
		*(src->zi)=mod->ioPz+((size_t)scalco);
	}
	fread(src->wav,sizeof(float),mod->nt,fp);
	for(isrc=1;isrc<src->nsrc;isrc++){
		fread(&hdr,1,TRCBYTES,fp);
		// Source Type & Orientation
		if(hdr.trid<1||hdr.trid>24) verr("In source file %s trace %d has an unknown source type (%d)",src->file_src,isrc+1,hdr.trid);
		src->typ[isrc]=(hdr.trid-1)%8+1;
		src->orient[isrc]=(hdr.trid-1)/8+1;
		// Number of Samples & Sampling Rate
		if(hdr.delrt!=0) verr("In source file %s trace %d has a non-zero delay time (%d)",src->file_src,isrc+1,hdr.delrt);
		if(hdr.dt!=mod->dtus)verr("Source trace %d does has a sampling rate of %dus, expected were %dus.",isrc+1,hdr.dt,mod->dtus);
		if(((size_t)hdr.ns)!=mod->nt)verr("Source trace %d does has %d samples, expected were %d.",isrc+1,hdr.ns,mod->nt);
		// Horizontal Source Location
		if(hdr.scalco<0){scalco=1/-((float)hdr.scalco);}else if(hdr.scalco>0){scalco=((float)hdr.scalco);}else scalco=1.;
		scalel=((float)hdr.sx)*scalco;
		if(scalel<mod->origx||scalel>mod->xmax) verr("In source file %s trace %d lies outside model bounds.",src->file_src,isrc+1);
		scalel=(scalel-mod->origx)/mod->dx+0.5;
		src->x[isrc]=truncf(scalel)*mod->dx+mod->origx;
		if(src->typ[isrc]==2||src->typ[isrc]==6){
			src->xi[isrc]=mod->ioXx+((size_t)scalel);
		}else{
			src->xi[isrc]=mod->ioPx+((size_t)scalel);
		}
		// Vertical Source Location
		if(hdr.scalel<0){scalel=1/-((float)hdr.scalel);}else if(hdr.scalel>0){scalel=((float)hdr.scalel);}else scalel=1.;
		scalco=((float)hdr.selev)*scalel;
		if(scalco<mod->origz||scalco>mod->zmax) verr("In source file %s trace %d lies outside model bounds.",src->file_src,isrc+1);
		scalco=(scalco-mod->origz)/mod->dz+0.5;
		src->z[isrc]=truncf(scalco)*mod->dz+mod->origz;
		if(src->typ[isrc]==2||src->typ[isrc]==7){
			src->zi[isrc]=mod->ioZz+((size_t)scalco);
		}else{
			src->zi[isrc]=mod->ioPz+((size_t)scalco);
		}
		fread(&src->wav[isrc*nt],sizeof(float),mod->nt,fp);
	}
	fclose(fp);

	/**************************************************/
	/* Ensure Free Surface Txz Sources Are Monopoles. */
	/**************************************************/
	for(isrc=0;isrc<src->nsrc;isrc++){
		if(src->typ[isrc]==2&&src->orient[isrc]!=1){
			if((bnd->lef==1&&src->xi[isrc]!=0)||(bnd->rig==1&&src->xi[isrc]!=mod->nx)||(bnd->top==1&&src->zi[isrc]!=0)||(bnd->bot==1&&src->zi[isrc]!=mod->nz)){
				src->typ[isrc]=0;
				verr("In source file %s Txz Source %d is on a free surface.",src->file_src,isrc+1);
			}
		}
	}

	/*************/
	/* Transpose */
	/*************/
	if(src->nsrc!=1){
		ptr=(float*)_mm_malloc(nt*nx*sizeof(float),64);
		transpose_block(src->wav,ptr,mod->nt,src->nsrc,nx,nt,16);
		_mm_free(src->wav);
		src->wav=(float*)malloc(mod->nt*mod->nx*sizeof(float)); //Hopefully ends up in same memory space
		for(nt=0;nt<mod->nt;nt++){
			for(isrc=0;isrc<src->nsrc;isrc++){
				src->wav[nt*src->nsrc+isrc]=ptr[nt*mod->nx+isrc];
			}
		}
		_mm_free(ptr);
	}

	return(0);
}